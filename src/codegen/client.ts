import { ExportMap } from "ts-protoc-gen/lib/ExportMap"
import { Printer } from "ts-protoc-gen/lib/Printer"
import { FileDescriptorProto } from "google-protobuf/google/protobuf/descriptor_pb"
import { CodeGeneratorResponse } from "google-protobuf/google/protobuf/compiler/plugin_pb"
import { createFile, RPCMethodDescriptor, RPCDescriptor, GrpcServiceDescriptor } from "ts-protoc-gen/lib/service/common"
import { convertTypeToCSharp, removePseudoNameFromImportDescriptor, snakeCaseToCamelCase } from "./shared"
import * as path from 'path'

export function generateDclRpcService(
  filename: string,
  descriptor: FileDescriptorProto,
  exportMap: ExportMap
): CodeGeneratorResponse.File[] | null {
  const code = generateClientTypeScriptDefinition(descriptor, exportMap)
  if (code == null)
    return null

  const baseName = snakeCaseToCamelCase(path.basename(filename))
  return [createFile(code, `Client${baseName}Service.gen.cs`)]
}

function getCallName(method: RPCMethodDescriptor) {
  if (method.requestStream && method.responseStream) {
    return 'CallBidirectionalStream'
  } else if (method.responseStream) {
    return 'CallServerStream'
  } else if (method.requestStream) {
    return 'CallClientStream'
  } else {
    return 'CallUnaryProcedure'
  }

}

function generateClientTypeScriptDefinition(fileDescriptor: FileDescriptorProto, exportMap: ExportMap): string | null {

  const serviceDescriptor = new GrpcServiceDescriptor(fileDescriptor, exportMap)
  if (serviceDescriptor.services.length == 0)
    return null

  const removePseudoName = (text: string) => {
    return removePseudoNameFromImportDescriptor(text, serviceDescriptor.imports)
  }

  const printer = new Printer(0)

  // Header.
  printer.printLn(`
// AUTOGENERATED, DO NOT EDIT
// Type definitions for server implementations of ports.
// package: ${serviceDescriptor.packageName}
// file: ${serviceDescriptor.filename}`)

  if (serviceDescriptor.services.length === 0) {
    return printer.getOutput()
  }

  // Import statements.
  printer.printLn(
`using Cysharp.Threading.Tasks;
using rpc_csharp;`)
  printer.printEmptyLn()

  if (serviceDescriptor.packageName.length > 0) {
    printer.printLn(`namespace ${serviceDescriptor.packageName} {`)
  }

  // Services.
  serviceDescriptor.services.forEach((service) => {
    const className = `Client${service.name}`
    printer.printLn(
`public class ${className}
{
  private readonly RpcClientModule module;

  public ${className}(RpcClientModule module)
  {
      this.module = module;
  }`)

    service.methods.forEach((method) => {
      const responseType = convertTypeToCSharp(removePseudoName(method.responseType))
      const requestType = convertTypeToCSharp(removePseudoName(method.requestType))
      const responseTypeEx = method.responseStream ? `IUniTaskAsyncEnumerable<${responseType}>` : `UniTask<${responseType}>`
      const requestTypeEx = method.requestStream ? `IUniTaskAsyncEnumerable<${requestType}>` : requestType
      const requestVarName = method.requestStream ? `streamRequest` : `request`
      const callName = getCallName(method)

      printer.printLn(
`
  public ${responseTypeEx} ${method.nameAsPascalCase}(${requestTypeEx} ${requestVarName})
  {
      return module.${callName}<${responseType}>("${method.nameAsPascalCase}", ${requestVarName});
  }`)
    })

    printer.printLn(`}`)
  })

  if (serviceDescriptor.packageName.length > 0) {
    printer.printLn(`}`)
  }

  return printer.getOutput()
}
