import { ExportMap } from "ts-protoc-gen/lib/ExportMap"
import { Printer } from "ts-protoc-gen/lib/Printer"
import { FileDescriptorProto } from "google-protobuf/google/protobuf/descriptor_pb"
import { CodeGeneratorResponse } from "google-protobuf/google/protobuf/compiler/plugin_pb"
import { createFile, RPCMethodDescriptor, RPCDescriptor, GrpcServiceDescriptor } from "ts-protoc-gen/lib/service/common"

export function generateServerRpcService(
  filename: string,
  descriptor: FileDescriptorProto,
  exportMap: ExportMap
): CodeGeneratorResponse.File[] {
  return [createFile(generateServerTypeScriptDefinition(descriptor, exportMap), `${filename}Service.cs`)]
}

function generateServerTypeScriptDefinition(fileDescriptor: FileDescriptorProto, exportMap: ExportMap): string {
  const serviceDescriptor = new GrpcServiceDescriptor(fileDescriptor, exportMap)
  const printer = new Printer(0)

  printer.print(`
// AUTOGENERATED, DO NOT EDIT
// Type definitions for server implementations of ports.
// package: ${serviceDescriptor.packageName}
// file: ${serviceDescriptor.filename}
using Google.Protobuf;
using rpc_csharp.server;
  `)

  if (serviceDescriptor.services.length === 0) {
    return printer.getOutput()
  }

  // Services.
  serviceDescriptor.services.forEach((service) => {
    const methodsPrinter = new Printer(0)
    const registerMethodPrinter = new Printer(0)
    service.methods.forEach((method) => {
      let type = method.responseStream ? `IEnumerator<Task<${method.responseType}>>` : `Task<Book>`
      methodsPrinter.printIndentedLn(`public abstract ${type} ${method.nameAsPascalCase}(${method.requestType} request, Context context);`)

      if (method.responseStream) {
        registerMethodPrinter.printLn(`      result.streamDefinition.Add("${method.nameAsPascalCase}", (payload, context) => { return ${method.nameAsPascalCase}(${method.requestType}.Parser.ParseFrom(payload), context); });`)
      } else {
        registerMethodPrinter.printLn(`      result.definition.Add("${method.nameAsPascalCase}", async (payload, context) => { var res = await ${method.nameAsPascalCase}(${method.requestType}.Parser.ParseFrom(payload), context); return res.ToByteArray(); });`)
      }
    })

    printer.print(`
public abstract class ${service.name}<Context>
{
  public string ServiceName = "${service.name}";

${methodsPrinter.output}

  public ServerModuleDefinition<Context> GetModuleDefinition()
  {
      var result = new ServerModuleDefinition<Context>();
      
${registerMethodPrinter.output}
      return result;
  }

  private IEnumerator<Task<byte[]>> RegisterStreamFn<T>(IEnumerator<Task<T>> generator)
  where T : IMessage
  {
    using (var iterator = generator)
    {
      while (iterator.MoveNext())
      {
        var response = iterator.Current.Result.ToByteArray();
        yield return Task.FromResult(response);
      }
    }
  }
}
    `)
    printer.printEmptyLn()
  })

  return printer.getOutput()
}
