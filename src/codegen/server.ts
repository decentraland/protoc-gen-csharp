import { ExportMap } from "ts-protoc-gen/lib/ExportMap"
import { Printer } from "ts-protoc-gen/lib/Printer"
import { FileDescriptorProto } from "google-protobuf/google/protobuf/descriptor_pb"
import { CodeGeneratorResponse } from "google-protobuf/google/protobuf/compiler/plugin_pb"
import { createFile, RPCMethodDescriptor, RPCDescriptor, GrpcServiceDescriptor, ImportDescriptor } from "ts-protoc-gen/lib/service/common"

export function generateServerRpcService(
  filename: string,
  descriptor: FileDescriptorProto,
  exportMap: ExportMap
): CodeGeneratorResponse.File[] {
  return [createFile(generateServerTypeScriptDefinition(descriptor, exportMap), `${filename}Service.gen.cs`)]
}

function removePseudoNameFromImportDescriptor(text: string, imports: ImportDescriptor[]) {
  for (let i of imports) {
    text = text.replace(i.namespace + ".", '')
  }
  return text
}

function generateServerTypeScriptDefinition(fileDescriptor: FileDescriptorProto, exportMap: ExportMap): string {
  const serviceDescriptor = new GrpcServiceDescriptor(fileDescriptor, exportMap)
  const printer = new Printer(0)
  printer.printLn(
`// AUTOGENERATED, DO NOT EDIT
// Type definitions for server implementations of ports.
// package: ${serviceDescriptor.packageName}
// file: ${serviceDescriptor.filename}
// file: ${JSON.stringify(serviceDescriptor.imports)}
using System.Collections.Generic;
using Cysharp.Threading.Tasks;
using Google.Protobuf;
using rpc_csharp.server;`)

  const removePseudoName = (text: string) => {
    return removePseudoNameFromImportDescriptor(text, serviceDescriptor.imports)
  }

  if (serviceDescriptor.services.length === 0) {
    return printer.getOutput()
  }

  if (serviceDescriptor.packageName.length > 0) {
    printer.printLn(`namespace ${serviceDescriptor.packageName} {`)
  }

  // Services.
  serviceDescriptor.services.forEach((service) => {
    const methodsPrinter = new Printer(0)
    const registerMethodPrinter = new Printer(0)
    service.methods.forEach((method) => {
      const responseType = removePseudoName(method.responseType)
      const requestType = removePseudoName(method.requestType)
      let type = method.responseStream ? `IEnumerator<UniTask<${responseType}>>` : `UniTask<${responseType}>`
      methodsPrinter.printIndentedLn(`public abstract ${type} ${method.nameAsPascalCase}(${requestType} request, Context context);`)

      if (method.responseStream) {
        registerMethodPrinter.printLn(`      result.streamDefinition.Add("${method.nameAsPascalCase}", (payload, context) => { return ${method.nameAsPascalCase}(${requestType}.Parser.ParseFrom(payload), context); });`)
      } else {
        registerMethodPrinter.printLn(`      result.definition.Add("${method.nameAsPascalCase}", async (payload, context) => { var res = await ${method.nameAsPascalCase}(${requestType}.Parser.ParseFrom(payload), context); return res.ToByteArray(); });`)
      }
    })

    printer.print(`
public abstract class ${service.name}<Context>
{
  public string ServiceName = "${service.name}";

${methodsPrinter.output}

  public ServerModuleDefinition<Context> GetModuleDefinition()
  {
      var result = new ServerModuleDefinition<Context>();
      
${registerMethodPrinter.output}
      return result;
  }

  private IEnumerator<UniTask<byte[]>> RegisterStreamFn<T>(IEnumerator<UniTask<T>> generator)
  where T : IMessage
  {
    using (var iterator = generator)
    {
      while (iterator.MoveNext())
      {
        var response = iterator.Current.Result.ToByteArray();
        yield return UniTask.FromResult(response);
      }
    }
  }
}
    `)
    printer.printEmptyLn()
  })

  if (serviceDescriptor.packageName.length > 0) {
    printer.printLn(`}`)
  }

  return printer.getOutput()
}
