import { ExportMap } from "ts-protoc-gen/lib/ExportMap"
import { Printer } from "ts-protoc-gen/lib/Printer"
import { FileDescriptorProto } from "google-protobuf/google/protobuf/descriptor_pb"
import { CodeGeneratorResponse } from "google-protobuf/google/protobuf/compiler/plugin_pb"
import { createFile, RPCMethodDescriptor, RPCDescriptor, GrpcServiceDescriptor, ImportDescriptor } from "ts-protoc-gen/lib/service/common"

export function generateServerRpcService(
  filename: string,
  descriptor: FileDescriptorProto,
  exportMap: ExportMap
): CodeGeneratorResponse.File[] {
  return [createFile(generateServerTypeScriptDefinition(descriptor, exportMap), `${filename}Service.gen.cs`)]
}

function removePseudoNameFromImportDescriptor(text: string, imports: ImportDescriptor[]) {
  for (let i of imports) {
    text = text.replace(i.namespace + ".", '')
  }
  return text
}

function generateServerTypeScriptDefinition(fileDescriptor: FileDescriptorProto, exportMap: ExportMap): string {
  const serviceDescriptor = new GrpcServiceDescriptor(fileDescriptor, exportMap)
  const printer = new Printer(0)
  printer.printLn(
`// AUTOGENERATED, DO NOT EDIT
// Type definitions for server implementations of ports.
// package: ${serviceDescriptor.packageName}
// file: ${serviceDescriptor.filename}
using System.Collections.Generic;
using Cysharp.Threading.Tasks;
using Google.Protobuf;
using rpc_csharp.protocol;
using rpc_csharp;`)

  const removePseudoName = (text: string) => {
    return removePseudoNameFromImportDescriptor(text, serviceDescriptor.imports)
  }

  if (serviceDescriptor.services.length === 0) {
    return printer.getOutput()
  }

  if (serviceDescriptor.packageName.length > 0) {
    printer.print(`namespace ${serviceDescriptor.packageName} {`)
  }

  // Services.
  serviceDescriptor.services.forEach((service) => {
    const serviceHeaderPrinter = new Printer(0)
    const methodsPrinter = new Printer(0)
    const registerMethodPrinter = new Printer(0)
    service.methods.forEach((method) => {
      const responseType = removePseudoName(method.responseType)
      const requestType = removePseudoName(method.requestType)
      let type = method.responseStream ? `IEnumerator<${responseType}>` : `UniTask<${responseType}>`

      serviceHeaderPrinter.print(`, ${method.nameAsPascalCase} ${method.nameAsCamelCase}`)

      methodsPrinter.printEmptyLn()
      methodsPrinter.printIndentedLn(`public delegate ${type} ${method.nameAsPascalCase}(${requestType} request, Context context);`)

      if (method.responseStream) {
        registerMethodPrinter.printLn(`    result.streamDefinition.Add("${method.nameAsPascalCase}", (payload, context) => { return new ProtocolHelpers.StreamEnumerator<${responseType}>(${method.nameAsCamelCase}(${requestType}.Parser.ParseFrom(payload), context)); });`)
      } else {
        registerMethodPrinter.printLn(`    result.definition.Add("${method.nameAsPascalCase}", async (payload, context) => { var res = await ${method.nameAsCamelCase}(${requestType}.Parser.ParseFrom(payload), context); return res?.ToByteString(); });`)
      }
    })

    printer.print(`
public abstract class ${service.name}<Context>
{
  public const string ServiceName = "${service.name}";
${methodsPrinter.output}
  public static void RegisterService(RpcServerPort<Context> port${serviceHeaderPrinter.output})
  {
    var result = new ServerModuleDefinition<Context>();
      
${registerMethodPrinter.output}
    port.RegisterModule(ServiceName, (port) => UniTask.FromResult(result));
  }`)
    printer.printEmptyLn()
    printer.printLn(`}`)
  })

  if (serviceDescriptor.packageName.length > 0) {
    printer.printLn(`}`)
  }

  return printer.getOutput()
}
